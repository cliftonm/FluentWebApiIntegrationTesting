<html>

<head>
<meta http-equiv="Content-Language" content="en-us">
<meta http-equiv="Content-Type" content="text/html; charset=windows-1252">
<title>Fluent Web API Integration Testi</title>
</head>

<body>

<p>Fluent Web API Integration Testing</p>
<p>Write readable integration tests that exclusively call Web API's.</p>
<h2>Contents</h2>
<div id="toc"><ul><ul><li><a href="#0">Introduction</a></li><li><a href="#1">Concept</a></li><li><a href="#2">Setup</a></li><ul><li><a href="#3">Web API Service</a></li><li><a href="#4">Demo Integration Tests DLL</a></li><li><a href="#5">The Clifton.IntegrationTestWorkflowEngine DLL</a></li><li><a href="#6">The WorkflowTestMethods DLL</a></li></ul><li><a href="#7">Our First Fluent Integration Test</a></li><ul><li><a href="#8">Refactoring the WorkflowPacket Class</a></li><li><a href="#9">Refactoring the ApiMethods Class</a></li><li><a href="#10">Test Result</a></li><li><a href="#11">Adding the Endpoint Call</a></li><li><a href="#12">Test Result</a></li><li><a href="#13">Refactoring the Endpoint</a></li><li><a href="#14">Test Result</a></li><li><a href="#15">Review</a></li></ul><li><a href="#16">Real Endpoint Fluent Integration Tests</a></li><ul><li><a href="#17">Adding the Generic Get REST API Call</a></li><li><a href="#18">Adding the Workflow API Call Method</a></li><li><a href="#19">Review</a></li><li><a href="#20">Failure Testing</a></li><li><a href="#21">Using dynamic to Reduce Generic Parameter Specification</a></li></ul><li><a href="#22">Going Further - POST and using JSON Body</a></li><ul><li><a href="#23">A Simple In-Memory State-County Model</a></li><li><a href="#24">The State Controller</a></li><li><a href="#25">New Fluent API Endpoint Methods</a></li><li><a href="#26">The Integration Tests</a></li><li><a href="#27">Running the Tests</a></li><li><a href="#28">Review</a></li></ul><li><a href="#29">The Drawback of Fluency</a></li><li><a href="#30">Conclusion - What is the Pattern?</a></li></ul></ul></div>
<h2><a name="0">Introduction</a></h2>
<p>I was reading Pete O'Hanlon's article
<a href="https://www.codeproject.com/Articles/5287815/Excelsior-Building-Applications-Without-a-Safety-2">
"Execlsior! Building Applicatons Without a Safety Net - Part 1"</a> 
(he has more parts now, since my article took a while to write) and was 
inspired to finally sit down and write an article on fluent web API integrating 
testing, something I've been wanting to do for a while!</p>
<p>For the kind of work that I do, web API integration testing isn't just a 
simple matter of calling an API and verifying that I get the expected result, 
rather it's actually a workflow.&nbsp; For example, instead of setting up all 
the prerequisite data to conduct a single API test, the API itself is enlisted 
to do help with the data setup.&nbsp; Furthermore, the user's workflow is then 
tested which requires calling multiple endpoints sequentially.&nbsp; The benefits are:</p>
<ol>
	<li>It simplifies the test setup process.</li>
	<li>It more closely simulates what the user might do or what the front-end 
	application does for the user.</li>
	<li>It vets the API for whether it truly supports atomic, if you will, 
	behavior as opposed to, say, a controller that does a dozen different 
	things.<ol>
		<li>Yes, you may still have endpoints that perform complex operations, 
		but the point is these should be based on more "atomic" methods that 
		simpler API endpoints can call.</li>
	</ol>
	</li>
	<li>If models are used, it tends to enforce an architecture is which the 
	models are maintained in a separate assembly that can be shared between the 
	service implementation and the integration test application.</li>
	<li>The concept integrates well with <a href="https://fluentassertions.com/">
	Fluent Assertions</a>, which we'll use here.</li>
</ol>
<h2><a name="1">Concept</a></h2>
<p>The concept is very simple:</p>
<ol>
	<li>We have an integration test suite (actually implemented using the unit 
	test framework)...</li>
	<li>...that calls methods in our "fluent" library...</li>
	<li>...which calls the desired endpoints...</li>
	<li>...and we can capture the results.</li>
</ol>
<p>The last part "we can capture the results" is the interesting part, as we 
want to capture:</p>
<ol>
	<li>The resulting HTTP status code and text.</li>
<li>The returned JSON (yes, I'm assuming everything is going to be JSON).</li>
	<li>Deserialize the JSON if there are no errors in the call.</li>
	<li>Associate the deserialized object with a label that we can use to 
	reference it later on.</li>
</ol>
<p>This requires that we implement a wrapper class for the test workflow that 
manages the information described above.&nbsp; I've never been able to come up 
with a good name for this, so I'll simply call it the "workflow packet."</p>
<h2><a name="2">Setup</a></h2>
<h3><a name="3">Web API Service</a></h3>
<p>We'll create a new VS 2019 project:</p>
<p><img border="0" src="createNewProject.png" width="352" height="84"></p>
<p>and select:</p>
<p><img border="0" src="webapi.png" width="525" height="117"></p>
<p>and I'm going to call the project "FluentWebApiIntegrationTestDemo."</p>
<p>Visual Studio 2019 creates the basic template for the web API, including a 
sample Weather Forecast controller:</p>
<p><img border="0" src="weather.png" width="243" height="111"></p>
<p>which I'm going to rename and gut, so it looks simply like this:</p>
<pre>using System;

using Microsoft.AspNetCore.Mvc;

namespace FluentWebApiIntegrationTestDemo.Controllers
{
  [ApiController]
  [Route("[controller]")]
  public class DemoController : ControllerBase
  {
    [HttpGet]
    public object Get()
    {
      throw new NotImplementedException();
    }
  }
}</pre>
<p>and delete the WeatherForecast.cs file.</p>
<p>For testing in the browser, the Debug configuration will open the browser on 
the controller name:</p>
<p>
<img border="0" src="config1.png" width="250" height="33"></p>
<p>and will launch IIS so I don't have to deal with port silliness:</p>
<p><img border="0" src="config2.png" width="250" height="32"></p>
<p>We can then run the project (VS will provision IIS the first time, which is 
awesome), and we see:</p>
<p><img border="0" src="error1.png" width="796" height="170"></p>
<p>Great!</p>
<h3><a name="4">Demo Integration Tests DLL</a></h3>
<p>Next, I'll add an MSTest Test Project (.NET Core) - yes, I'm using the unit 
test framework to perform integration tests.</p>
<p><img border="0" src="testproj1.png" width="690" height="247"></p>
<p>Creating the integration test project resulted in a nightmare of errors:</p>
<p><img border="0" src="error2.png" width="616" height="223"></p>
<p>The only "solution" I found was to put the web API project and the 
integration test project side-by-side:</p>
<p><img border="0" src="sidebyside.png" width="237" height="47"></p>
<p>Whatever Visual Studio is doing with projects created in the same folder as 
the Web Core API project...well, it's doing too much, as the folder structure 
should not, in my opinion, have anything to do with how the Web Core API project 
is built.</p>
<p>I also upgraded the packages:</p>
<p><img border="0" src="error3.png" width="251" height="97"></p>
<p>to:</p>
<p><img border="0" src="nuget1.png" width="233" height="93"></p>
<p>So finally that builds.</p>
<p>The initial UnitTest1.cs file that VS creates, I've renamed to "DemoTests" 
and this stub looks like this:</p>
<pre>using Microsoft.VisualStudio.TestTools.UnitTesting;

namespace IntegrationTests
{
  [TestClass]
  public class DemoTests
  {
    [TestMethod]
    public void GetTest()
    {
    }
  }
}</pre>
<p>Of course, the test doesn't do anything, so we have a successful test!&nbsp; 
Sorry Pete.</p>
<p><img border="0" src="pass1.png" width="185" height="107"></p>
<h3><a name="5">The Clifton.IntegrationTestWorkflowEngine DLL</a></h3>
<p>Because these integration tests can actually be leveraged as "live" 
workflows, I'm going to create a separate .NET Core Class Library project for 
managing the fluent integration workflow packet:</p>
<p><img border="0" src="WorkflowEngine.png" width="419" height="57"></p>
<p>which at the moment contains just a stub file:</p>
<pre>namespace Clifton.IntegrationTestWorkflowEngine
{
  public class WorkflowPacket
  {
  }
}</pre>
<p>This seems like overkill to create a DLL with just one class, but we may want 
to add additional functionality later.&nbsp; The point here is that we want a 
reusable class that does not allow us to add "domain specific" implementations, 
thus we create a separate DLL to prevent that.</p>
<h3><a name="6">The WorkflowTestMethods DLL</a></h3>
<p>And if the above wasn't enough, yes, we're going to create one more .NET Core 
Class Library DLL to actually contain the workflow methods.&nbsp; This will 
allow us to use the workflow methods directly in the API if we so choose to 
expose workflows to the user.&nbsp; Might as well plan ahead rather than 
refactor later.&nbsp; This DLL <i>is</i> domain specific - it will contain 
methods for calling endpoints in our demo API service.</p>
<p>It also has a stub class:</p>
<pre>namespace WorkflowTestMethods
{
  public class ApiMethods
  {
  }
}</pre>
<h2><a name="7">Our First Fluent Integration Test</a></h2>
<p>After setting up a couple project references, we an write our first fluent 
integration test:</p>
<pre>string baseUrl = "<a href="http://localhost/FluentWebApiIntegrationtestDemo">http://localhost/FluentWebApiIntegrationtestDemo</a>";

new WorkflowPacket(baseUrl)
  .Home("Demo")
  .IShouldSeeOKResponse();</pre>
<p>This doesn't compile because we haven't implemented a constructor that takes 
the base URL nor the supporting methods, 
but from the syntax with can glean:</p>
<ol>
	<li>The fluent methods are extensions on the <code>WorkflowPacket</code></li>
	<li>Each fluent method returns the <code>WorkflowPacket</code> instance.</li>
</ol>
<h3><a name="8">Refactoring the WorkflowPacket Class</a></h3>
<p>Refactoring the <code>WorkflowPacket</code> class:</p>
<pre>using System.Net;

namespace Clifton.IntegrationTestWorkflowEngine
{
  public class WorkflowPacket
  {
    public HttpStatusCode LastResponse { get; set; }
    public string BaseUrl { get; protected set; }

    public WorkflowPacket(string baseUrl)
    {
      this.BaseUrl = baseUrl;
    }
  }
}</pre>
<h3><a name="9">Refactoring the ApiMethods Class</a></h3>
<p>Refactoring the ApiMethods (I also added the FluentAssertions package) class:</p>
<pre>using FluentAssertions;

using Clifton.IntegrationTestWorkflowEngine;
using System.Net;

namespace WorkflowTestMethods
{
  public static class ApiMethods
  {
    public static WorkflowPacket Home(this WorkflowPacket wp, string controller)
    {
      return wp; 
    }

    public static WorkflowPacket IShouldSeeOKResponse(this WorkflowPacket wp)
    {
      wp.LastResponse.Should().Be(HttpStatusCode.OK, $"Did not expected {wp.LastContent}");

      return wp;
    }

    public static WorkflowPacket IShouldSeeNoContentResponse(this WorkflowPacket wp)
    {
      wp.LastResponse.Should().Be(HttpStatusCode.NoContent, $"Did not expected {wp.LastContent}");

      return wp;
    }

    public static WorkflowPacket IShouldSeeBadRequestResponse(this WorkflowPacket wp)
    {
      wp.LastResponse.Should().Be(HttpStatusCode.BadRequest, $"Did not expected {wp.LastContent}");

      return wp;
    }
  }
}</pre>
<p>Now, FluentAssertions is a bit lame.&nbsp; One can say "we assert that x 
should be y <i>because</i> [some reason]", but there's no mechanism to say "we 
assert that x should be y <i>but it is not for the reason</i> [fail reason].&nbsp; 
So that's why the "because" parameter has "Did not expected...".&nbsp; Sigh.</p>
<h3><a name="10">Test Result</a></h3>
<p>We see that the integration test failed (obviously, because we're not calling 
the endpoint yet):</p>
<p><img border="0" src="ut2.png" width="179" height="93"></p>
<p>The amazing thing about about FluentAssertions is that it tells you exactly 
what the issue is:</p>
<p><img border="0" src="error5.png" width="373" height="38"></p>
<h3><a name="11">Adding the Endpoint Call</a></h3>
<p>Using RestSharp (yet another package), which I'm going to wrap in a 
RestService class and put in the Clifton.IntegrationTestWorkflowEngine (hah! 
see, I told you we would add more to this DLL!), we have a simple GET API call 
method:</p>
<pre>using System.Net;

using RestSharp;

namespace Clifton.IntegrationTestWorkflowEngine
{
  public static class RestService
  {
    public static (HttpStatusCode status, string content) Get(string url)
    {
      var response = Execute(url, Method.GET);

      return (response.StatusCode, response.Content);
    }

    private static IRestResponse Execute(string url, Method method)
    {
      var client = new RestClient(url);
      var request = new RestRequest(method);
      var response = client.Execute(request);

      return response;
    }
  }
}</pre>
<p>We then refactor the <code>ApiMethods.Home</code> method to make the call:</p>
<pre>public static WorkflowPacket Home(this WorkflowPacket wp, string controller)
{
  var resp = RestService.Get($"{wp.BaseUrl}/{controller}");
  wp.LastResponse = resp.status;

  return wp; 
}</pre>
<h3><a name="12">Test Result</a></h3>
<p>The test still fails, but now we see why:</p>
<p><img border="0" src="error4.png" width="499" height="42"></p>
<h3><a name="13">Refactoring the Endpoint</a></h3>
<p>So the last step is to refactor the endpoint so it doesn't throw a 
<code>NotImplementedException</code> exception but instead returns OK:</p>
<pre>[HttpGet]
public object Get()
{
  return Ok();
}</pre>
<h3><a name="14">Test Result</a></h3>
<p><img border="0" src="ut3.png" width="175" height="92"></p>
<p>And finally the test passes!</p>
<h3><a name="15">Review</a></h3>
<p>What have we accomplished?&nbsp; Given this simple example:</p>
<pre>new WorkflowPacket(baseUrl)
  .Home("Demo")
  .IShouldSeeOKResponse();</pre>
<p>We have created the basic framework for:</p>
<ol>
	<li>Calling endpoints</li>
	<li>Verifying status returns</li>
</ol>
<p>Let's extend this further to now to work with more "real" API endpoints.</p>
<h2><a name="16">Real Endpoint Fluent Integration Tests</a></h2>
<p>The purpose here is to be able to pass in some data to an endpoint (query 
string or serialization) and obtain the result (deserialization) and test the 
result.&nbsp; So, for example:</p>
<pre>[TestMethod]
public void FactorialTest()
{
  string baseUrl = "<a href="http://localhost/FluentWebApiIntegrationtestDemo">http://localhost/FluentWebApiIntegrationtestDemo</a>";

  new WorkflowPacket(baseUrl)
   .Factorial&lt;FactorialResult&gt;("factResult", 6)
   .IShouldSeeOKResponse()
   .ThenIShouldSee&lt;FactorialResult&gt;("factResult", r =&gt; r.Result.Should().Be(720));
}

[TestMethod]
public void BadFactorialTest()
{
  string baseUrl = "<a href="http://localhost/FluentWebApiIntegrationtestDemo">http://localhost/FluentWebApiIntegrationtestDemo</a>";

  new WorkflowPacket(baseUrl)
    .Factorial&lt;FactorialResult&gt;("factResult", -1)
    .IShouldSeeBadRequestResponse();
}</pre>
<p>Note that this implies that the workflow packet now stores the result in the 
indicated "container", in this case, "factResult."</p>
<p>Also note that I am expecting, in the second test, that an HTTP response of 
BadRequest will be returned if I try to obtain the factorial of a number less 
than 1.</p>
<p>I'm going to put the FactorialResult "model" into another DLL that is shared 
by both the integration test and the API service:</p>
<pre>namespace FluentWebApiIntegrationTestDemoModels
{
  public class FactorialResult
  {
    public decimal Result { get; set; }
  }
}</pre>
<p>Because these are generic methods, we do <i>not</i> add this DLL to the 
WorkflowTestMethods project.</p>
<h3><a name="17">Adding the Generic Get REST API Call</a></h3>
<p>Adding the Newtonsoft.Json package, we implement:</p>
<pre>public static (T item, HttpStatusCode status, string content) Get&lt;T&gt;(string url) where T : new()
{
  var response = Execute(url, Method.GET);
  T ret = TryDeserialize&lt;T&gt;(response);

  return (ret, response.StatusCode, response.Content);
}

private static T TryDeserialize&lt;T&gt;(IRestResponse response) where T : new()
{
  T ret = new T();
  int code = (int)response.StatusCode;

  if (code &gt;= 200 &amp;&amp; code &lt; 300)
  {
    ret = JsonConvert.DeserializeObject&lt;T&gt;(response.Content);
  }

  return ret;
}</pre>
<h3><a name="18">Adding the Workflow API Call Method</a></h3>
<p>Here, the endpoint to the <code>Factorial</code> method in the <code>Math</code> controller, is 
hard-coded, which I think is perfectly fine because the description of the API 
call method should be specific so that the integration test is readable <i>by 
its method name</i> not by its parameters.</p>
<pre>public static WorkflowPacket Factorial&lt;T&gt;(this WorkflowPacket wp, string containerName, int n) where T: new()
{
  var resp = RestService.Get&lt;T&gt;($"{wp.BaseUrl}/Math/Factorial?n={n}");
  wp.LastResponse = resp.status;
  wp.Container[containerName] = resp.item;

  return wp;
}

public static WorkflowPacket ThenIShouldSee&lt;T&gt;(this WorkflowPacket wp, string containerName, Action&lt;T&gt; test) where T : class
{
  T obj = wp.GetObject&lt;T&gt;(containerName);
  test(obj);

  return wp;
}</pre>
<p>Notice that I've now added the concept of containers to the WorkflowPacket, 
such that I can add objects to the container and return the container object, 
cast to the specified type.</p>
<pre>public Dictionary&lt;string, object&gt; Container = new Dictionary&lt;string, object&gt;();
...
public T GetObject&lt;T&gt;(string containerName) where T: class
{
  Container.Should().ContainKey(containerName);
  T ret = Container[containerName] as T;

  return ret;
}</pre>
<p>Of course the test fails because I haven't implemented that <code>Math</code> controller with the <code>Factorial</code> 
method, so let's do that now as a stub:</p>
<pre>[ApiController]
[Route("[controller]")]
public class MathController : ControllerBase
{
  [HttpGet("Factorial")]
  public object Factorial([FromQuery, BindRequired] int n)
  {
    return Ok(new FactorialResult());
  }
}</pre>
<p>Again, the test fails, but we see:</p>
<p><img border="0" src="ut4.png" width="334" height="41"></p>
<p>So let's actually implement the factorial computation:</p>
<pre>[ApiController]
[Route("[controller]")]
public class MathController : ControllerBase
{
  [HttpGet("Factorial")]
  public object Factorial([FromQuery, BindRequired] int n)
  {
    object ret;

    if (n &lt;= 0)
    {
      ret = BadRequest("Value must be &gt;= 1");
    }
    else
    {
      decimal factorial = 1;
      n.ForEach(i =&gt; factorial = factorial * i, 1);

      ret = Ok(new FactorialResult() { Result = factorial });
    }

    return ret;
  }
}</pre>
<p>(Yes, I like my extension methods.)&nbsp; Note how I specifically coded a 
test to make sure <code>n</code> is greater than 0.</p>
<p>And we see:</p>
<p><img border="0" src="ut5.png" width="172" height="64"></p>
<h3><a name="19">Review</a></h3>
<p>Given this integration test:</p>
<pre>new WorkflowPacket(baseUrl)
   .Factorial&lt;FactorialResult&gt;("factResult", 6)
   .IShouldSeeOKResponse()
   .ThenIShouldSee&lt;FactorialResult&gt;("factResult", r =&gt; r.Result.Should().Be(720));</pre>
<p>and barring the fact that we unfortunately have to over-specify the generics, 
we see that we can:</p>
<ol>
	<li>Make an API endpoint call with a query parameter.</li>
	<li>Deserialize the result.</li>
	<li>Verify the result.</li>
</ol>
<h3><a name="20">Failure Testing</a></h3>
<p>We also implemented a simple integration test that verifies that the API 
gracefully handles bad input with a simple workflow:</p>
<pre> new WorkflowPacket(baseUrl)
  .Factorial&lt;FactorialResult&gt;("factResult", -1)
  .IShouldSeeBadRequestResponse();
</pre>
<h3><a name="21">Using dynamic to Reduce Generic Parameter Specification</a></h3>
<p>If we wanted to use the dynamic feature of C# (though we lose Intellisense), we could, with a slightly 
different workflow method, write:</p>
<pre>.ThenIShouldSee("factResult", r =&gt; r.Result.Should().Be(720));</pre>
<p>Except that we get an exception from the runtime binder:</p>
<p><img border="0" src="error6.png" width="791" height="57"></p>
<p>We could implement a dynamic <code>ThenIShouldSee</code> like this:</p>
<pre>public static WorkflowPacket ThenIShouldSee(this WorkflowPacket wp, string containerName, Func&lt;dynamic, bool&gt; test)
{
  var obj = wp.GetObject(containerName);
  var b = test(obj);
  b.Should().BeTrue();

  return wp;
}
</pre>
<p>with the test written as:</p>
<pre>.ThenIShouldSee("factResult", r =&gt; r.Result == 720M);</pre>
<p>but then look what happens:</p>
<p><img border="0" src="error7.png" width="776" height="62"></p>
<p>What?&nbsp; It turns out that <code>var b</code>, even though we and the complier know b is of type <code>bool</code>, 
does not work well with FluentAssertions.&nbsp; We actually have to write <code>bool b</code> for FluentAssertions to work!</p>
<h2><a name="22">Going Further - POST and using JSON Body</a></h2>
<p>It's more typical in an integration test to emulate several activities that 
the user might perform.&nbsp; For this example, we'll create some tests that, if 
there was a UI, would let the user enter states and counties for each state, and 
view the counties by state.&nbsp; A simple set of endpoints which I'll implement 
directly in memory -- I won't even use an in-memory database!&nbsp; Granted, 
this is a somewhat contrived example, but it illustrates more interesting 
integration tests.</p>
<h3><a name="23">A Simple In-Memory State-County Model</a></h3>
<p>I'm going to move away from Test-Driven Development (TDD) and do what feels 
more natural to me when I'm writing fairly simple code -- just write the 
implementation and then write the tests to verify the implementation.&nbsp; I 
call this Test-Later Coding - TLC, hahaha.&nbsp; Here's the model, and note how 
I code specific exceptions in the model:</p>
<pre>namespace FluentWebApiIntegrationTestDemoModels
{
  public class StateModelException : Exception
  {
    public StateModelException() { } 
    public StateModelException(string msg) : base(msg) { }
  }

  public class County : List&lt;string&gt; { }

  public class StateModel
  {
    // Public for serialization
    public Dictionary&lt;string, County&gt; StateCounties { get; set; } = new Dictionary&lt;string, County&gt;();

    public IEnumerable&lt;string&gt; GetStates()
    {
      var ret = StateCounties.Select(kvp =&gt; kvp.Key);

      return ret;
    }

    public IEnumerable&lt;string&gt; GetCounties(string stateName)
    {
      Assertion.That&lt;StateModelException&gt;(StateCounties.ContainsKey(stateName), "State does not exist.");

      return StateCounties[stateName];
    }

    public void AddState(string stateName)
    {
      Assertion.That&lt;StateModelException&gt;(!StateCounties.ContainsKey(stateName), "State already exists.");

      StateCounties[stateName] = new County();
    }
    
    public void AddCounty(string stateName, string countyName)
    {
      Assertion.That&lt;StateModelException&gt;(StateCounties.ContainsKey(stateName), "State does not exists.");
      Assertion.That&lt;StateModelException&gt;(!StateCounties[stateName].Contains(countyName), "County already exists.");

      StateCounties[stateName].Add(countyName);
    }
  }
}</pre>
<p>We want to assert for expected conditions in the model, not the controller, 
so that the model may be re-used with all its validation.</p>
<h3><a name="24">The State Controller</a></h3>
<p>Here's the controller:</p>
<pre>[ApiController]
[Route("[controller]")]
public class StateController : ControllerBase
{
  public static StateModel stateModel  = new StateModel();

  [HttpGet("")]
  public object GetStates()
  {
    var states = stateModel.GetStates();

    return Ok(states);
  }

  [HttpPost("")]
  public object AddState([FromBody] string stateName)
  {
    object ret = Try&lt;StateModelException&gt;(
      NoContent(), 
      () =&gt; stateModel.AddState(stateName));

    return ret;
  }

  [HttpPost("{stateName}/County")]
  public object AddCounty(
  [FromRoute, BindRequired] string stateName,
  [FromBody] string countyName)
  {
    object ret = Try&lt;StateModelException&gt;(
      NoContent(), 
      () =&gt; stateModel.AddCounty(stateName, countyName));

    return ret;
  }
}</pre>
<p>Because I really don't like to repeat myself and I also don't like to clutter 
my code with <code>try-catch</code> blocks and if possible, <code>if-else</code> statements, 
I created a helper function that if we see the expected exception from the 
model, then return a bad request, otherwise throw the exception and let the 
framework return an internal server error.&nbsp; This code illustrates that most 
API methods should really be doing very simple things that have a limited set of 
exceptions.&nbsp; While more complicated API endpoints will have the possibility 
of throwing a variety of exceptions, I bring this up here more as a talking / 
discussion point than as a guidance.&nbsp; The point for me, when I teach 
software development / architecture, is to get people to think about questions 
they should be asking rather than just diving into robotic coding.</p>
<pre>private object Try&lt;T&gt;(object defaultReturn, Action action)
{
  object ret = defaultReturn;

  try
  {
    action();
  }
  catch (Exception ex)
  {
    if (ex.GetType().Name == typeof(T).Name)
    {
      ret = BadRequest(ex.Message);
    }
    else
    {
      throw;
    }
  }

  return ret;
}</pre>
<h3><a name="25">New Fluent API Endpoint Methods</a></h3>
<p>I've added 3 more fluent methods.&nbsp; With regards to the first one, it 
does seem a bit absurd to decouple the class definition that will hold the 
result from the method endpoint call.&nbsp; Yes, there are times when you want 
to deserialize only specific key-values of the return data, and then there are 
times like this, where it makes more sense to just have the fluent endpoint 
method "know" into what the model is that the data goes.&nbsp; Such is the case 
here.</p>
<pre>public static WorkflowPacket GetStatesAndCounties(this WorkflowPacket wp, string containerName)
{
  var resp = RestService.Get&lt;StateModel&gt;($"{wp.BaseUrl}/States");
  wp.LastResponse = resp.status;
  wp.Container[containerName] = resp.item;

  return wp;
}

public static WorkflowPacket AddState(this WorkflowPacket wp, string stateName)
{
  var resp = RestService.Post($"{wp.BaseUrl}/State", new { stateName });
  wp.LastResponse = resp.status;

  return wp;
}

public static WorkflowPacket AddCounty(this WorkflowPacket wp, string stateName, string countyName)
{
   var resp = RestService.Post($"{wp.BaseUrl}/State/${stateName}/County", new { countyName });
  wp.LastResponse = resp.status;

  return wp;
}</pre>
<p>And now we need a <code>Post</code> method in our <code>RestService</code>:</p>
<pre>public static (HttpStatusCode status, string content) Post(string url, object data = null)
{
  var response = Execute(Method.POST, url, data);

  return (response.StatusCode, response.Content);
}</pre>
<p>And of course the Execute method must now support data in the request:</p>
<pre>private static IRestResponse Execute(Method method, string url, object data = null)
{
  var client = new RestClient(url);
  var request = new RestRequest(method);
  data.IfNotNull(() =&gt; request.AddJsonBody(data));
  var response = client.Execute(request);

  return response;
}</pre>
<h3><a name="26">The Integration Tests</a></h3>
<p>Now we can write positive and negative integration tests:</p>
<pre>[TestMethod]
public void AddStateTest()
{
  string baseUrl = "http://localhost/FluentWebApiIntegrationtestDemo";

  new WorkflowPacket(baseUrl)
    .AddState("NY")
    .IShouldSeeNoContentResponse()
    .AddState("CT")
    .IShouldSeeNoContentResponse()
    .GetStatesAndCounties("myStates")
    .IShouldSeeOKResponse()
    .ThenIShouldSee&lt;StateModel&gt;("myStates", m =&gt; m.GetStates().Count().Should().Be(2));
}

[TestMethod]
public void AddDuplicateStateTest()
{
  string baseUrl = "<a href="http://localhost/FluentWebApiIntegrationtestDemo">http://localhost/FluentWebApiIntegrationtestDemo</a>";

  new WorkflowPacket(baseUrl)
    .AddState("NY")
    .IShouldSeeNoContentResponse()
    .AddState("NY")
    .IShouldSeeBadRequestResponse();
}

[TestMethod]
public void AddCountyTest()
{
  string baseUrl = "<a href="http://localhost/FluentWebApiIntegrationtestDemo">http://localhost/FluentWebApiIntegrationtestDemo</a>";

  new WorkflowPacket(baseUrl)
    .AddState("NY")
    .IShouldSeeNoContentResponse()
    .AddCounty("NY", "Columbia")
    .GetStatesAndCounties("myStates")
    .IShouldSeeOKResponse()
    .ThenIShouldSee&lt;StateModel&gt;("myStates", m =&gt; m.GetStates().Count().Should().Be(1))
    .ThenIShouldSee&lt;StateModel&gt;("myStates", m =&gt; m.GetStates().First().Should().Be("NY"))
    .ThenIShouldSee&lt;StateModel&gt;("myStates", m =&gt; m.GetCounties("NY").Count().Should().Be(1))
    .ThenIShouldSee&lt;StateModel&gt;("myStates", m =&gt; m.GetCounties("NY").First().Should().Be("Columbia"));
}

[TestMethod]
public void AddCountyNoStateTest()
{
  string baseUrl = "http://localhost/FluentWebApiIntegrationtestDemo";

  new WorkflowPacket(baseUrl)
    .AddCounty("NY", "Columbia")
    .IShouldSeeBadRequestResponse();
}

[TestMethod]
public void AddDuplicateCountyTest()
{
  string baseUrl = "<a href="http://localhost/FluentWebApiIntegrationtestDemo">http://localhost/FluentWebApiIntegrationtestDemo</a>";

  new WorkflowPacket(baseUrl)
    .AddState("NY")
    .IShouldSeeNoContentResponse()
    .AddCounty("NY", "Columbia")
    .IShouldSeeNoContentResponse()
    .AddCounty("NY", "Columbia")
    .IShouldSeeBadRequestResponse();
}</pre>
<h3><a name="27">Running the Tests</a></h3>
<p>We have a problem with the simplest integration test, adding a state.</p>
<p><img border="0" src="error8.png" width="145" height="47"></p>
<p>Looking at the response in Postman, we see:</p>
<pre>"The JSON value could not be converted to System.String. Path: $ | LineNumber: 0 | BytePositionInLine: 1."</pre>
<p>Oops.&nbsp; The reason is obvious -- I implemented the body parameter as a 
string, not a class.&nbsp; It also seems reasonable then to change not just the 
endpoint for adding the state, but also adding a county to the state:</p>
<pre>public class StateCountyName
{
  public string StateName { get; set; }
  public string CountyName { get; set; }
}

[HttpPost("")]
public object AddState([FromBody] StateCountyName name)
{
  object ret = Try&lt;StateModelException&gt;(
    NoContent(), 
    () =&gt; stateModel.AddState(name.StateName));

  return ret;
}

[HttpPost("County")]
public object AddCounty(
  [FromBody] StateCountyName name)
{
  object ret = Try&lt;StateModelException&gt;(
    NoContent(), 
    () =&gt; stateModel.AddCounty(name.StateName, name.CountyName));

  return ret;
}</pre>
<p>Yes, we could add validation for null values and empty strings, but I'm not 
going to bore you with those details.</p>
<p>Now when I run the AddStateTest, I get back this nasty exception:</p>
<p><code>Newtonsoft.Json.JsonSerializationException: Cannot deserialize the current 
JSON array (e.g. [1,2,3]) into type 'FluentWebApiIntegrationTestDemoModels.StateModel' 
because the type requires a JSON object (e.g. {"name":"value"}) to deserialize 
correctly.</code></p>
<p>That's because I'm doing something stupid.&nbsp; The "get states" API 
function is returning a list of states, as strings, and we're expecting the 
response to be the <code>StateModel</code>.&nbsp; So let's fix that:</p>
<pre>[HttpGet("")]
public object GetStates()
{
  return Ok(stateModel);
}</pre>
<p>Of course the real problem here is that we shouldn't be exposing the internal 
dictionary of the <code>StateModel</code> but instead mapping this to a different collection.&nbsp; 
But that's besides the point for this article.</p>
<p>So now I see:</p>
<p><img border="0" src="ut6.png" width="105" height="27"></p>
<p>Yay! But...</p>
<p><img border="0" src="ut7.png" width="112" height="22"></p>
<p>Because:</p>
<pre>Expected wp.LastResponse to be NoContent because Did not expected "State already exists.", but found BadRequest.</pre>
<p>Oops.&nbsp; For our testing, we need to reset our psuedo-database.&nbsp; 
Technically, this should be done in the cleanup of every test, which will 
actually be an API call:</p>
<pre>[TestCleanup]
public void CleanupData()
{
  string baseUrl = "<a href="http://localhost/FluentWebApiIntegrationtestDemo">http://localhost/FluentWebApiIntegrationtestDemo</a>";

  new WorkflowPacket(baseUrl)
    .CleanupStateTestData()
    .IShouldSeeOKResponse();
}</pre>
<p>Implemented as:</p>
<pre>[HttpPost("CleanupTestData")]
public object CleanupTestData()
{
  stateModel = new StateModel();

  return Ok();
}</pre>
<p>However, this actually is the wrong way to do this, especially when debugging 
integration tests -- what we actually want is to clean up the test data <i>
before</i> each test is run!</p>
<pre>[TestInitialize]
public void CleanupData()
{
  new WorkflowPacket(baseUrl)
    .CleanupStateTestData()
    .IShouldSeeOKResponse();
}</pre>
<p>Finally we have success:</p>
<p><img border="0" src="ut8.png" width="195" height="101"></p>
<p>Lastly, I'm getting tired of having this line:</p>
<pre>string baseUrl = "http://localhost/FluentWebApiIntegrationtestDemo";</pre>
<p>in every single test.&nbsp; So instead, the test class will derive from a 
<code>Setup</code> class that can be extended to perform other setup/teardown functionality 
as well.</p>
<pre>public class Setup
{
  public static string baseUrl = "http://localhost/FluentWebApiIntegrationtestDemo";
}</pre>
<p>This concept can be extended to parameterize the URL so that different 
servers (local, test, QA) can be used so that the integration tests can be 
performed at each step of the testing / deployment process.&nbsp; I often use 
the <code>Setup</code> base class to perform login/authentication as well as 
complex data setup (always by making endpoint calls!) that is used in multiple 
integration tests.</p>
<h3><a name="28">Review</a></h3>
<p>Here we've done something more interesting because the integration test 
requires more than one step.&nbsp; To add a county, the state must first exist.&nbsp; 
This basic test:</p>
<pre>new WorkflowPacket(baseUrl)
  .AddState("NY")
  .IShouldSeeNoContentResponse()
  .AddCounty("NY", "Columbia")
  .GetStatesAndCounties("myStates")
  .IShouldSeeOKResponse()
  .ThenIShouldSee&lt;StateModel&gt;("myStates", m =&gt; m.GetStates().Count().Should().Be(1))
  .ThenIShouldSee&lt;StateModel&gt;("myStates", m =&gt; m.GetStates().First().Should().Be("NY"))
  .ThenIShouldSee&lt;StateModel&gt;("myStates", m =&gt; m.GetCounties("NY").Count().Should().Be(1))
  .ThenIShouldSee&lt;StateModel&gt;("myStates", m =&gt; m.GetCounties("NY").First().Should().Be("Columbia"));</pre>
<p>could be extended to test that multiple states and multiple states per county 
are handled correctly, that updating and deleting names works, and so forth.&nbsp; 
If we were using a real DB, it would be reasonable for the API endpoints to 
return the record with the primary key field which could then be used to add 
counties, rather than specifying the state name.&nbsp; And if you have a 
consistent naming convention for your primary key (like "ID", why people insist 
on including the table name in the primary key name is beyond me) you can 
implement the fluent API methods to look up the object by it's name, so you can 
write:</p>
<pre>.AddState("nyState", "NY")
.AddCounty("columbiaCounty", "nyState", "Columbia")</pre>
<p>and the implementation would look something like:</p>
<pre>AddCounty(string countyBucketName, string stateBucketName, string countyName)
{
  int id = (wp.Container[stateBucketName] as IHasId).ID;
  var resp = RestService.Post&lt;County&gt;($"{wp.BaseUrl}/State/{id}/County", new { countyName });
  wp.LastResponse = resp.status;
  wp.LastContent = resp.content;
  wp.Container[countyBucketName] = resp.item;
}</pre>
<p>Hopefully that concept makes sense - the idea is to use the object returned 
by the API endpoint in further calls to the fluent API method, assuming you've 
gone about coding your models and endpoints with some intelligence.</p>
<h2><a name="29">The Drawback of Fluency</a></h2>
<p>The problem with a fluent API (not the endpoint API!) is that if an exception 
occurs you don't really know where you are in the chain of method calls.&nbsp; 
To help ameliorate this problem, we can implement a list of the method calls so that when a failure 
occurs, we can display to the developer where in the method chain the failure 
occurred.&nbsp; For example, each fluent API method can log itself:</p>
<pre>public static WorkflowPacket Factorial&lt;T&gt;(this WorkflowPacket wp, string containerName, int n) where T: new()
{
  wp.Log("Factorial");
  ...</pre>
<p>If we do this consistently, then we can display the log at any time:</p>
<pre>public static WorkflowPacket PrintLog(this WorkflowPacket wp)
{
  wp.CallLog.ForEach(item =&gt; wp.Write(item));

  return wp;
}

public static WorkflowPacket Write(this WorkflowPacket wp, string msg)
{
  System.Diagnostics.Debug.WriteLine(msg);

  return wp;
}</pre>
<p>If I add <code>PrintLog</code> to the end of the integration test that adds a state and a 
county, we then see:</p>
<p><img border="0" src="ut9.png" width="202" height="152"></p>
<p>However, that is not sufficient.&nbsp; What we really want is for the test 
cleanup to print out the log, so for a test failure, we can see where it fails.&nbsp; 
First, we refactor the test fixture itself to instantiate the <code>WorkflowPacket</code> for 
each test:</p>
<pre>private WorkflowPacket wp;

[TestInitialize]
public void InitializeTest()
{
  wp = new WorkflowPacket(baseUrl)
    .CleanupStateTestData()
    .IShouldSeeOKResponse();
}

[TestCleanup]
public void CleanupTest()
{
  wp.PrintLog();
}</pre>
<p>and now every test uses wp instead of instantiating it's own <code>WorkflowPacket</code>.&nbsp; 
So the test to create the state automatically looks like this:</p>
<pre>[TestMethod]
public void AddCountyAndAutoCreateStateTest()
{
  wp
    .AddCounty("NY", "Columbia")
    .IShouldSeeNoContentResponse()
    .GetStatesAndCounties("myStates")
    .IShouldSeeOKResponse()
    .ThenIShouldSee&lt;StateModel&gt;("myStates", m =&gt; m.GetStates().Count().Should().Be(1))
    .ThenIShouldSee&lt;StateModel&gt;("myStates", m =&gt; m.GetStates().First().Should().Be("NY"))
    .ThenIShouldSee&lt;StateModel&gt;("myStates", m =&gt; m.GetCounties("NY").Count().Should().Be(1))
    .ThenIShouldSee&lt;StateModel&gt;("myStates", m =&gt; m.GetCounties("NY").First().Should().Be("Columbia"));
}</pre>
<p>which of course fails and we can see on which step the test failed:</p>
<p><img border="0" src="ut10.png" width="804" height="110"></p>
<p>And we see that it failed in the call to <code>AddCounty</code>.</p>
<h2><a name="30">Conclusion - What is the Pattern?</a></h2>
<p>The pattern for this approach is simple enough and you can pretty much 
start anywhere for how you like to do things, which of course always depends on 
what the task to do actually is!</p>
<p><img border="0" src="process.png" width="337" height="453"></p>
<p>Once you get into the habit of writing these kind of integration tests, it 
becomes second nature.&nbsp; I find that I actually <i>want</i> to write the 
integration test before touching any code:</p>
<ul>
	<li>First to prove that the code is wrong;</li>
	<li>Second to prove that the fix works;</li>
	<li>Third to prove that the fix didn't break something else.</li>
</ul>
<p>I find this approach to also be much more efficient than using an actual web 
page test application that simulate the user's actions directly on the browser.&nbsp; 
With this approach, I can write the web API's before the UI is ever implemented 
and have proof that the web API works according to the spec.&nbsp; Similarly, if 
my web API integration tests pass, then the problem is on the front-end.</p>
<p>Now you might say, well all this could be handled with unit testing.&nbsp; 
And I say no, it can't.&nbsp; In actual practice, I work with complex 
interdependent data, the code base was not designed to be unit testable (it 
never is) and the business rules are splattered across various class instances 
and trigger events.&nbsp; Testing any of this discretely does not build any 
confidence what-so-ever that when the user clicks on the "Save" button, that all 
the logic does what it's supposed to do.&nbsp; Conversely, with and integration 
test, I can set up all the different configurations of the data through other 
endpoints (which at the same time tests other parts of the code) and then call 
the "Save" API endpoint that triggers all the business rules.&nbsp; From there, 
I can request the data back as the user would see it and verify that everything 
looks correct.</p>
<p>And at the end of the day, the point of writing the integration tests in a 
fluent manner and using FluentAssertions is simply the feedback I keep getting: 
"wow, this is actually readable!"&nbsp; Hopefully you'll have that experience as 
well.&nbsp; I also hope you've enjoyed reading how I created a fluent web API 
integration test "framework" and the steps and thinking that went into it.</p>

</body>

</html>